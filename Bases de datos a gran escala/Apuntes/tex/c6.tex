\begin{tikzpicture}
    \node[fill=pastelpink, fill opacity=1, text opacity=1, text width=0.7\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (0, 0) {
        \begin{minipage}{0.3\textwidth}
            \textbf{\textsf{Interés NoSQL}} \\[-10pt]
            \begin{itemize}
                \item Funciona aprovechando los recursos de un \textit{cluster} de computación
                \item Usa el agregado como unidad natural de distribución de datos.
            \end{itemize}
        \end{minipage}
        \hspace{0cm}
        \begin{minipage}{0.39\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Ventajas}} \\[-10pt]
                    \begin{itemize}
                        \item Capacidad para gestionar un mayor volumen de datos. 
                        \item Se puede incrementar el tráfico de operaciones de lectura y escritura (rendimiento), así como la disponibilidad (tolerancia a fallos).
                    \end{itemize}
                };
            \end{tikzpicture}
        \end{minipage}
        \hspace{-0.2cm}
        \begin{minipage}{0.3\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Desventajas}} \\[-10pt]
                    \begin{itemize}
                        \item Sistema más complejo. Usar solo en caso necesario
                    \end{itemize}
                };
            \end{tikzpicture}
        \end{minipage}
    };

    \node[fill=powderblue, fill opacity=1, text opacity=1, text width=0.25\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (10.2, 0) {
        \textbf{\textsf{Formas de replicación de los datos}} \\[-10pt]
        \begin{itemize}
        \item Replicación: se hacen varias copias del mismo dato en distintos nodos. Válida para arquitecturas maestro-esclavo o \textit{peer-to-peer}. 
        \item Particionamiento (sharding): repartir los datos entre los nodos. 
        \item Técnicas ortogonales: se pueden combinar
        \end{itemize}
    };

    \node[fill=softpeach, fill opacity=1, text opacity=1, text width=0.75\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (0.45, -6.5) {
        \textbf{\textsf{Sharding}} \\[2pt]
        El particionamiento es una técnica usada cuando se tienen distintos usuarios accediendo a partes distintas de la base de datos. Para mejorar el rendimiento, se dividen los datos y se coloca cada parte en un nodo distinto. Cada \textit{shard} lee y escribe sobre su propia partición de datos. Esto nos proporciona escalabilidad horizontal.  \\

        Debemos intentar mantener la localidad de los datos, es decir, que los datos que se acceden juntos estén en el mismo nodo y cerca en el disco. Para ello, mantenemos los datos que se suelen acceder juntos en el mismo agregado y usamos el agregado como unidad de datos para la distirbución. También es recomendable mantener cerca agregados que se suelen usar juntos. \\

        Además, es recomendable mantener todos los nodos con una carga de datos similar, lo que podemos conseguir haciendo una distribución uniforme de los datos. \\

        Implementar el \textit{sharding} en el nivel de la aplicación es mucho más complejo. Muchas BD NoSQL gestionan el \textit{sharding} de forma automática. \\

        \begin{itemize}
            \item En cuanto a rendimiento, el particionamiento mejora lectura y escrituras, mientras que la replicación puede mejorar lecturas pero empeorar escrituras.
            \item En cuanto a la fiabilidad, el particionamiento no mejora la disponibilidad, aumenta la probabilidad de fallo y puede haber fallos parciales.
        \end{itemize}
    };

    \node[fill=softpeach, fill opacity=1, text opacity=1, text width=0.2\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (10.7, -5) {
        \textbf{\textsf{Un solo servidor}} \\[2pt]
        En este caso no existe la distribución de datos. Es la opción preferida por ser el mas simple, y el uso de NoSQL se justificaría por cuestiones relacionadas con el modelo de datos. Las BD de grafos suelen usar esta arquitectura. Los datos agregados se procesan en el nivel de la aplicación y se recuperan juntos.
    };

    \node[fill=softpeach, fill opacity=1, text opacity=1, text width=0.75\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (0.45, -14) {
        \begin{minipage}{0.39\textwidth}
            \textbf{\textsf{Replicación Maestro-Esclavo}} \\[-10pt]
            \begin{itemize}
            \item Buena solución cuando la aplicación es intensiva en lecturas. Aquí, los datos se reparte en varios nodos.
            \item Un nodo es elegido como maestro (autoridad como fuente de los datos y responsable de su actualización) y el resto son esclavos.
            \item El proceso de replicación sincroniza los esclavos con el maestro. Cuanto más síncrono, mayor consistencia pero menos rendimiento y disponibilidad.
            \end{itemize}
            
        \end{minipage}
        \hspace{0cm}
        \begin{minipage}{0.3\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Ventajas}} \\[-10pt]
                    \begin{itemize}
                        \item Alta disponibilidad en lecturas !! ya que si el maestro falla, los esclavos pueden atender peticiones de lectura.
                        \item En caso de fallo del maestro hay que sustituirlo: si tenemos replicación completa del maestro podemos hacer recuperación en
                        caliente (manual o automática).
                    \end{itemize}
                };
            \end{tikzpicture}
        \end{minipage}
        \hspace{-0.2cm}
        \begin{minipage}{0.3\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Problemas}} \\[-10pt]
                    \begin{itemize}
                        \item El maestro es un cuello de botella en modificaciones, dando problemas en caso de muchas escrituras. 
                        \item Baja disponibilidad en lecturas.
                        \item Consistencia: un esclavo puede leer datos no actualizados aún (\textit{read-write}).
                    \end{itemize}
                };
            \end{tikzpicture}
        \end{minipage}
    };

    \node[fill=softpeach, fill opacity=1, text opacity=1, text width=\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (2.87, -20.2) {
        \begin{minipage}{0.4\textwidth}
            \textbf{\textsf{Replicación \textit{Peer-to-peer}}} \\[-10pt]
            \begin{itemize}
            \item Motivada por los problemas de la replicación maestro-esclavo: escalabilidad en escritura y baja disponibilidad, el maestro es cuello de botella y punto único de fallo.
            \item Ahora, se elimina la distinción entre maestro y esclavo, todos los nodos se comunican entre ellos y pueden leer y escribir todos los datos.
            \end{itemize}
            
        \end{minipage}
        \hspace{0cm}
        \begin{minipage}{0.3\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Problemas}} \\[2pt]
                    Existen problemas de consistencia por conflictos \textit{write-write}: dos usuarios modifican el mismo dato a la vez en distintos nodos !! Esto es grave ya que genera problemas que perduran, no como los de \textit{read-write}, que generan problemas transitorios. 
                };
            \end{tikzpicture}
        \end{minipage}
        \hspace{-0.2cm}
        \begin{minipage}{0.3\textwidth}
            \begin{tikzpicture}
                \node[fill=lemoncream, fill opacity=1, text opacity=1, text width=0.8\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
                (note2) at (0, 0) {
                    \textbf{\textsf{Soluciones generales}} \\[-10pt]
                    \begin{itemize}
                        \item Coordinar las replicas durantes la escritura: con actualizar la mayoría de forma coordinada es suficiente.
                        \item Asumir inconsistencias e intentar arreglarlas combinando réplicas.
                        \item Más adelante veremos soluciones más específicas.
                    \end{itemize}
                };
            \end{tikzpicture}
        \end{minipage}
    };

    \node[fill=powderblue, fill opacity=1, text opacity=1, text width=0.2\textwidth, align=justify, draw, rounded corners, inner sep=10pt] 
    (note1) at (10.7, -11.7) {
        \textbf{\textsf{Combinación particionamiento-replicación}} \\[2pt]
        \begin{itemize}
        \item Con maestro-esclavo: usariamos un maestro para cada partición. Dependiendo de la configuración, podemos elegir maestro y esclavos a nivel \textit{cluster} o para cada partición.
        \item Con \textit{peer-to-peer}: común en NoSQL con modelos de tipo \textit{column-family}. Se usa una replicación con factor 3, por lo que cada partición tiene 3 copias en 3 nodos y si un nodo falla, sus particiones se distribuyen entre los demás.
        \end{itemize}
    };

\end{tikzpicture}



